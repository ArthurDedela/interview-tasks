# Замыкания и объекты

## IIFE

Пример объявления:

```js

(function IIFE() {
  console.log('iife');
})();

(function IIFE(){
  console.log('iife');
}());

```

Пример использования:

```js

var a = 2;

(function IIFE(def){
  def( window );
})(function def(global) {
  var a = 3;
  console.log(a); // 3
  console.log(global.a) // 2
});

```

## let и const

Ключевое слово `let` и `const` присоединяет объявление переменной к области видимости того блока, в которой оно содержится. Иначе говоря, `let` и `const` неявно заимствует область видимости любого блока для объявления своей переменной.

Пример:

```js

var foo = true;

if (foo) {
  let bar = foo * 2;
  bar = something( bar );
  console.log( bar );
}

console.log( bar ); // ReferenceError

```

## Замыкания

Замыкание - способность функции запомнить свою лексическую область видимости и обращаться к ней даже тогда, когда функция выполняется вне своей лексической области видимости.

Несколько примеров помогут проиллюстрировать это определение.

```js

function foo() {
  var a = 2;
  
  function bar() {
    console.log( a ); // 2
  }
  
  bar();
}

foo();

```

Функция `bar()` обладает доступом к переменной `a` во внешней области видимости из-за правил поиска лексической области видимости (в данном случае это поиск RHS-ссылки).

Это и есть замыкание?

Чисто с технической точки зрения... *возможно*. Но если вспомнить наше приведенное выше определение "того, что вам нужно знать"... не со всем. Я думаю, что обращение `bar()` к `a` лучшего всего объясняется правилами поиска лексической области видимости, а эти правила являются лишь *составной частью* (хотя и важной) того, что называется замыканием.

С чисто теоретической точки зрения о приведенном фрагменте можно сказать, что функция `bar()` обладает *замыканием* над областями видимости `foo()` (а на самом деле и над остальными областями видимости, доступными для нее, например, глобальной областью видимости в данном случае). Если взглянуть на ситуацию несколько иначе, можно сказать, что `bar()` обладает замыканием над областью видимости `foo()`. Почему? Потому что функция `bar()` вложена в `foo()`. Просто и понятно.

Однако замыкания, определяемые таким образом, не видны напрямую, и мы не видим использования замыкания в этом фрагменте. Лексическая область видимости хорошо видна, но замыкание остается загадочной неуловимой тенью где-то за кодом. 

Давай рассмортрим код, который выводит замыкание на свет:

```js

function foo() {
  var a = 2;
  
  function bar() {
    console.log( a );
  }
  
  return bar;
}

var baz = foo();

baz(); // 2 -- вы только что увидели замыкание.

```

## this

Связывание `this` происходит в момент вызова функции, и то, на *что* ссылается `this`, определяется исключительно местов вызова, из которого была вызвана функция.



