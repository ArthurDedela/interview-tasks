# Преобразование типов

Таблица "ложных" значений: 

```js 
''
false
undefined, null
NaN, +0, -0
```

Если значение присутсвует в списке, оно является "ложным", и при применении приобразования к логическому типу вы получите `false`.

## Ложные объекты

Некоторые примеры, которые могут ввести Вас в заблуждение:

```js

var a = new Boolean(false);
var b = new Number(0);
var c = new String("");

```

Мы знаем, что все три значения являются объектами, в которых обернуты явно ложные значения. Но как будут интерпритироваться такие объекты: как `true` или как `false`? На этот вопрос легко ответить:

```js

var d = Boolean(a && b && c); // true

```

## Истинные значения

Пример: 

```js

var a = "false";
var b = "0";
var c = "''";

var d = Boolean(a && b && c); // true

```

Потому что, несмотря на то что содержимое этих строковых значений выглядит как ложные значения, сами строковые значения все истинны, так как `""` -- единственный строковое значение в ложном списке.

А как в таком случае?

```js

var a = [];
var b = {};
var c = function() {}

var d = Boolean(a && b && c); // true

```

`d` -- все равно содержит `true`. Почему? По той же причине, что и прежде. Чтоб бы Вам так не казалось, `[]`,`{}`, `function() {}` *не* входят в ложный список, а следовательно являются истинными значениями.

## Явные преобразования: * --> Boolean

```js
var a = "0";
var b = [];
var c = {};

var d = "";
var e = 0;
var f = null;
var g;

!!a; // true
!!b; // true
!!c; // true

!!d; // false
!!e; // false
!!f; // false
!!g; // false
```

Подобному тому как унарный оператор `+` преобразует значение в число (см. ниже), унарный оператор отрицания `!` явно преобразует значение в `boolean`. *Проблема* в том, что значение при этом переходит из истинного в ложное и наоборот. Итак, для преобразования в `boolean` разработчики JS чаще всего используют оператор двойного отрицания `!!`, потому что второй `!` возвращает разряд в исходное состояние.

## Явные преобразования String <--> Number

```js

var a = 42;
var b = a.toString(); // "42"

var c = "1.78";
var d = +c; // 1.78 

```

`ToString()` не может вызываться для *примитивных* значений, таких как `42`. JS автоматически "упаковывает" `42` в объектную обертку, чтобы для объекта можно было вызвать `toString()`.

`+c` здесь демонстрирует *унарную форму* оператора `+`. Вместо выполнения математического сложения унарный `+` явно преобразует свой операнд `c` в числовое значение.

## Преобразование даты в число

```js

var d = new Date("Mon, 18 Aug 2014 08:53:06 CDT");
+d; // 1408369986000

```

Чаще всего эта идиома применяется для получения текущего момента времени в виде временного штампа:

```js
var timestamp = +new Date();
```

Но *лучше* воспользоваться статической функцией `Date.now()`, добавленной в ES5.
Рекомендую держаться подальше от форм преобразования, связанных с датами. Используйте `Date.now()`.

## Некоторые интересные штуки

**NaN**:

`NaN` - является числом.

```js

var a = 2 / 'string';

typeof a === "number" // true

```

`NaN` - единственное значение в JS, которое не равно самому себе

```js

var a = 2 / 'string';
a !== a // true
a != a // true

```
