[Ссылка на литературу](https://github.com/azat-io/you-dont-know-js-ru/blob/master/types%20%26%20grammar/README.md#you-dont-know-js-types--grammar)

# Преобразование типов

Таблица "ложных" значений: 

```js 
''
false
undefined, null
NaN, +0, -0
```

Если значение присутсвует в списке, оно является "ложным", и при применении приобразования к логическому типу вы получите `false`.

## Ложные объекты

Некоторые примеры, которые могут ввести Вас в заблуждение:

```js

var a = new Boolean(false);
var b = new Number(0);
var c = new String("");

```

Мы знаем, что все три значения являются объектами, в которых обернуты явно ложные значения. Но как будут интерпритироваться такие объекты: как `true` или как `false`? На этот вопрос легко ответить:

```js

var d = Boolean(a && b && c); // true

```

## Истинные значения

Пример: 

```js

var a = "false";
var b = "0";
var c = "''";

var d = Boolean(a && b && c); // true

```

Потому что, несмотря на то что содержимое этих строковых значений выглядит как ложные значения, сами строковые значения все истинны, так как `""` -- единственный строковое значение в ложном списке.

А как в таком случае?

```js

var a = [];
var b = {};
var c = function() {}

var d = Boolean(a && b && c); // true

```

`d` -- все равно содержит `true`. Почему? По той же причине, что и прежде. Чтоб бы Вам так не казалось, `[]`,`{}`, `function() {}` *не* входят в ложный список, а следовательно являются истинными значениями.

## Явные преобразования: * --> Boolean

```js
var a = "0";
var b = [];
var c = {};

var d = "";
var e = 0;
var f = null;
var g;

!!a; // true
!!b; // true
!!c; // true

!!d; // false
!!e; // false
!!f; // false
!!g; // false
```

Подобному тому как унарный оператор `+` преобразует значение в число (см. ниже), унарный оператор отрицания `!` явно преобразует значение в `boolean`. *Проблема* в том, что значение при этом переходит из истинного в ложное и наоборот. Итак, для преобразования в `boolean` разработчики JS чаще всего используют оператор двойного отрицания `!!`, потому что второй `!` возвращает разряд в исходное состояние.

## Явные преобразования String <--> Number

```js

var a = 42;
var b = a.toString(); // "42"

var c = "1.78";
var d = +c; // 1.78 

```

`ToString()` не может вызываться для *примитивных* значений, таких как `42`. JS автоматически "упаковывает" `42` в объектную обертку, чтобы для объекта можно было вызвать `toString()`.

`+c` здесь демонстрирует *унарную форму* оператора `+`. Вместо выполнения математического сложения унарный `+` явно преобразует свой операнд `c` в числовое значение.

## Преобразование даты в число

```js

var d = new Date("Mon, 18 Aug 2014 08:53:06 CDT");
+d; // 1408369986000

```

Чаще всего эта идиома применяется для получения текущего момента времени в виде временного штампа:

```js
var timestamp = +new Date();
```

Но *лучше* воспользоваться статической функцией `Date.now()`, добавленной в ES5.
Рекомендую держаться подальше от форм преобразования, связанных с датами. Используйте `Date.now()`.

## Равенство строгое и нестрогое

`==` допускает преобразование типа при проверке равенства, а `===` запрещает преобразование типа.

```js

var a = 42;
var b = "42";

a === b; // false
a == b; // true

```

## Сравнение: объекты и необъекты

Если объект/функция/массив сравнивается с простым скалярным примитивом (`string`, `number` или `boolean`), в спецификации ES5 говорится следующее (раздел 11.9.3.8-9):
1. Если `Type(x)` относится к типу `String` или `Number`, а `Type(y)` относится к типу `Object`, вернуть результат сравнения `x == ToPrimitive(y)`.
2. Если `Type(x)` относится к типу `Object`, а `Type(y)` относится к типу `String` или `Number`, вернуть результат сравнения `ToPrimitive(x) == y`.

* *Возможно, вы заметили, что в этих разделах спецификации упоминается только `String` и `Number`, но не `Boolean`. Дело в том, что, как упоминалось выше, разделы 11.9.3.6-7 гарантируют, что любой опреанд `Boolean` был сначала представлен в виду `Number`*.

Пример:
```js

var a = 42;
var b = [ 42 ];

a == b // true

var c = "qwe";
var d = Object(c); // то же самое что `new String(c)`

c === d; // false
a == b; // true

```

Для значения `[ 42 ]` вызывается абстрактная операция `ToPrimitive`, которая дает результат `"42"`. С этого момента остается простое условие `"42" == 42`, так что `a` и `b` равны с точностью до преобразования типа.

## Некоторые интересные штуки

**NaN**:

`NaN` - является числом.

```js

var a = 2 / 'string';

typeof a === "number" // true

```

`NaN` - единственное значение в JS, которое не равно самому себе

```js

var a = 2 / 'string';
a !== a // true
a != a // true

```
